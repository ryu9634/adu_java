메소드(method)
- 어떤 로직이나 기능을 만들어 내는 방법(함수)
- 코드를 재활용 할 수 있도록 하여 경제적으로 코드를 작성할 수 있음

    접근제어자 [static] 반환타입 메소드명(매개변수1, 매개변수2 ..){
        메소드가 호출되면 실행될 문장;
        ...
        [return 반환값;]
    }

    예) static이 없는 메소드
    Scanner sc = new Scanner(System.in);
    sc.next();
    예) static이 붙은 메소드
    Math.random();


1. 이름만 호출하면 실행되는 메소드

    public static void method1(){
        System.out.println("Hello Java!");
    }

    method1();

2. 매개변수가 있는 메소드

    public static void method2(int num){
        System.out.println(num);
    }

    method2(10);

3. 매개변수가 있고, 리턴값이 있는 메소드

    public static int method3(int num){
        return num;
    }

    int num = method3(10);


문제.
사칙연산을 구하는 메소드를 각각 만들어 아래와 같이 출력하는 프로그램을 작성해보자.
(단, 메소드는 각 연산(+, -, *, /)마다 별도로 작성, return 키워드를 반드시 사용)

첫번째 숫자를 입력하세요 10
두번째 숫자를 입력하세요 3
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3.3333

절차지향 프로그래밍
- 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 됨
- 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
- C언어
- 가독성이 좋음, 여러명이 개발하기 힘듬

객체지향 프로그래밍
- 실제 세계를 모델링하여 소프트웨어를 개발하는 방법
- 데이터와 절차를 하나의 덩어리(집합)로 묶어서 생각
- 명사(변수), 동사(메소드)로 생각
- 여러명이 하나의 프로젝트를 개발하기 좋음, 설계가 힘듬

클래스(class)
- 설계도와 같은 의미
- 객체의 상태를 저장하는 필드(변수)와 객체의 행동을 나타내는 메소드(함수)로 구성

클래스(파일) -> 메모리(객체)

클래스 만드는 방법

    접근제어자 class 클래스명 {
        자료형 필드1;
        자료형 필드2;
        ...
        메소드1(){

        }
        메소드2(){

        }
        ...
    }

객체를 생성하는 방법

    클래스명 객체명 = new 생성자();

객체지향 프로그래밍, oop(Object Oriented Programming)

🎁 은닉화
- 내부 데이터, 내부 연산을 외부에서 접근하지 못하도록 은닉 혹은 격리시키는 것
- 변수에 접근제한자를 private로 지정
- setter, getter 메소드를 사용하여 변수의 접근, 제어함
🎁 추상화
- 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- 클래스를 정의하는 것
🎁 캡슐화
- 실제로 구현되는 부분을 외부에 드러나지 않도록 캡슐로 감싸 이용방법만 알려주는 것
- 변수와 함수를 하나로 묶는 것
- 객체가 맡은 역할을 수행하기 위한 하나의 목적을 하나로 묶는 과정


생성자(Constructor)
- new 연산자를 통해 객체를 생성할 때 반드시 호출, 제일 먼저 실행되는 메서드
- 클래스명과 동일한 이름을 가진 메서드
- 필드를 초기화 하는 역할
- 반환타입 없음
- 직접 생성하지 않으면 JVM이 자동으로 빈 생성자를 만들어 호출

    [public] 클래스명(){
        생성자가 호출되면 실행할 문장;
        ...
    }

필드의 선언과 초기값
byte : 0
short : 0
int : 0
long : 0
char : \u0000
float : 0.0
double : 0.0
boolean : false
String, 배열, 클래스, 인터페이스 : null

생성자 메소드 오버로딩
- 메소드명이 같고, 시그니처가 다른 생성자 메소드를 여러개 만드는 것
                -------
                파라미터의 개수와 타입

this 키워드 : 현재 클래스의 필드를 가리킴
    this.gender = gender;
this() : 현재 클래스의 생성자


객체의 배열
    클래스명[] 참조변수 = new 클래스명[요소의 개수];
    Member[] members = new Member[3];
    members[0] = new Member();
    members[1] = new Member();
    members[2] = new Member();

과제.
Student 클래스를 활용하여 아래와 같은 프로그램을 작성해보자.
(단, 생성자를 꼭! 사용함)
몇 명의 학생을 등록할까요? 4
1번째 학생의 번호를 입력하세요. 1
1번째 학생의 이름을 입력하세요. 김사과
1번째 학생의 국어점수를 입력하세요. 90
1번째 학생의 영어점수를 입력하세요. 80
1번째 학생의 수학점수를 입력하세요. 70
2번째 학생의 번호를 입력하세요. 2
...
4번째 학생의 수학점수를 입력하세요. 60

결과
Student{no=1, name='김사과', kor=90, math=70, eng=80, tot=240, avg=80}
...
Student{no=4, name='오렌지', kor=90, math=70, eng=80, tot=240, avg=80}







