컬렉션 프레임워크
- 여러가지 데이터를 메모리에서 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합
- 자료구조를 구현한 클래스의 모음

🎁 자료구조
- 데이터를 효율적으로 관리할 수 있는 데이터 구조를 의미
- 데이터의 특성에 따라 체계적으로 구조화함

🎁 알고리즘
- 어떤 문제를 풀기 위한 절차 및 방법
- 어떤 문제에 대해 입력을 넣으면 원하는 출력을 얻을 수 있도록 만드는 프로그래밍

List 인터페이스
- 순서가 있는 데이터들의 집합으로 데이터의 중복을 허용
- Vector, ArrayList, LinkedList, Stack, Queue

Set 인터페이스
- 순서가 없는 데이터 집합으로 데이터의 중복을 허용하지 않음
- HashSet, TreeSet

Map 인터페이스
- 키와 값을 한 쌍으로 이루어지는 데이터의 집합으로 순서가 없고, 키는 중복으로 허용하지 않지만
값은 중복될 수 있음
- HashMap, TreeMap, HashTable, Properties


Vector 클래스
- 동적인 길이로 여러 데이터형을 저장하기 위해 사용
- 자바 1.0부터 존재하는 레거시 클래스
- 배열과 동일하게 정수 인덱스를 이용하여 액세스 할 수 있음
- 동기화 되어 있으며 한번에 하나의 스레드만 벡터의 메소드를 호출 할 수 있음

🎁 동기식
    차례(순서)대로 처리
🎁 비동기식
    여러개의 프로그램을 동시에 처리, 시간이 오래 걸리면 다음 문장으로 이동 후 다시 돌아가는 방식

Vector<타입> 참조변수 = new Vector(요소의 개수);
addElement() : 요소를 추가
size() : 요소의 개수를 반환
capacity() : 현재 벡터에 저장 가능한 크기를 반환
get() : 인덱스로 저장된 값을 찾아 반환
removeAllElements() : 저장된 모든 요소를 삭제
set() : 인덱스로 저장된 값을 변경(설정)
    참조변수.set(인덱스, 값);

Queue
- FIFO(First in First Out)
- 큐의 한쪽 끝을 프론트로 정하여 삭제 연산만 수행함
- 다른 한쪽 끝을 리어로 정하여 삽입 연산만 수행함
- 운영체제의 스케줄러, 푸시메세지

offer() : 요소를 추가
peek() : 첫번째 데이터를 반환
poll() : 첫번째 데이터를 반환하고 제거
remove() : 값 제거
clear : queue 초기화

비주얼고
https://visualgo.net/en/list?slide=1


Stack
- LIFO(Last Input First Out)
- 한쪽 끝에서만 자료를 넣고 뺄 수 있는 형식의 자료구조
- 브라우저의 "뒤로가기", "앞으로가기"

push() : 요소를 저장
peek() : 마지막(첫번째 뽑힐) 데이터를 반환
pop() : 마지막(첫번째 뽑힐) 데이터를 반환하고 삭제
search() : 데이터의 순서 반환

ArrayList
- 동적인 길이로 여러 데이터형을 저장하기 위해 사용
- 배열과 동일하게 정수 인덱스를 이용하여 엑세스 할 수 있음
- 비동기식을 사용하며 멀티 스레드를 지원

ArrayList<타입> 참조변수 = new ArrayList();

add() : 요소를 추가
size() : 요소의 개수를 반환
remove() : 인덱스를 이용하여 요소를 삭제
set() : 인덱스로 저장된 값을 변경(설정)


Iterator 인터페이스
컬렉션 프레임워크 인터페이스에서는 Iterator 인터페이스를 구현한 클래스의 인스턴스를 반환하는 iterator()
메소드를 정의하여 각 요소에 접근하도록 설계
- 자바의 컬렉션에 저장되어 있는 요소들을 읽어오는 방법
- 컬렉션으로부터 정보를 얻어내는 방법

Iterator의 장점과 단점
장점 : 컬렉션 프레임워크 종류에 상관없이 일관성 있게 프로그래밍을 할 수 있음
단점 : size 메소드를 얻어와서 반복 처리하는 것 보다 속도가 좋지 못함


LinkedList
- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식
- ArrayList에 비해 데이터의 추가나 삭제가 빠름
- 인덱스가 없기 때문에 특정 요소에 접근이 느림
- 탐색속도가 떨어짐

✔ 탐색 또는 정렬을 자주하는 경우에는 배열을 사용하고, 데이터의 추가/삭제가 많은 경우에는 링크드리스트를
사용하는 것이 좋음

🎁 노드
데이터(값)와 포인터(주소)를 담고 있는 형태


HashSet
- 데이터를 중복해서 저장할 수 없음(중복을 자동으로 제거)
- 하나의 null값만 저장할 수 있음
- 저장 순서가 유지되지 않음
- 정렬을 하지 않음

중복을 걸러내는 과정
1. hashCode()를 이용하여 저장되어 있는 객체들의 해시 코드 값을 비교
2. equals()로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단

HashSet<타입> 참조변수 = new HashSet();

add() : 요소를 추가
size() : 요소의 개수를 반환


TreeSet
- 데이터를 중복해서 저장할 수 없음(중복을 자동으로 제거)
- 하나의 null값만 저장할 수 있음
- 저장 순서가 유지되지 않음
- 이진 탐색 트리 구조로 이루어져 있음
- 오름차순으로 정렬

🎁 이진 탐색 트리
추가와 삭제에는 시간이 걸리지만 정렬, 검색에 높은 성능을 자랑하는 자료구조


HashMap
- Map 인터페이스를 구현한 대표적인 클래스
- 키와 값으로 구성된 요소객체를 저장하는 구조를 가지고 있는 자료구조
- 키는 중복 저장될 수 없고, 값은 중복될 수 있음
- 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대체
- 해싱(Hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 뛰어난 성능
- 비동기식

    key(apple)              key 테이블                 value 테이블
    value(사과)   -------->   apple       (해시함수)       사과


TreeMap
- 이진트리를 기반으로 한 Map 클래스
- 키와 같이 저장된 Map, Entry를 저장함
- 키를 기준으로 오름차순 정렬
- HashMap보다 성능이 떨어짐

HashTable
- 키와 값의 데이터를 테이블에 저장
- 자바는 HashMap을 지원하기 때문에 HashTable을 구현하거나 사용하는 경우가 거의 없음
- 동기식
- null입력이 불가능

Properties
- HashTable을 상속받아 구현
- (String, String)의 형태로 저장(메소드)
- 애플리케이션 환경설정과 관련된 속성을 저장할 때 종종 사용
- 컬렉션프레임워크 이전의 구버전이므로 Iterator가 아닌 Enumration를 사용


과제1.
자바 배열을 이용하여 스택, 큐를 직접 구현하기

과제2.
학생 관리 프로그램을 만들어보자.

결과
메뉴는 선택하세요.
1.입력 2.출력 3.검색 4.삭제 5.수정 6.종료
1
학번을 입력하세요
반을 입력하세요
이름을 입력하세요
나이를 입력하세요
연락처를 입력하세요
2
학번 : 10000
반 : 1
이름 : 김사과
나이 : 20
연락처 : 010-1111-1111
3
검색할 학생의 학번을 입력하세요
10000
학번 : 10000
반 : 1
이름 : 김사과
나이 : 20
연락처 : 010-1111-1111
✔ 만약 찾지 못했을 경우 -> "찾는 학생의 정보가 없습니다"
4
삭제할 학생의 학번을 입력하세요
10000
삭제되었습니다!
5
수정할 학생의 학번을 입력하세요
10000
반을 입력하세요
이름을 입력하세요
나이를 입력하세요
연락처를 입력하세요
수정되었습니다




